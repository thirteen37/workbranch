#!/usr/bin/env zsh
# wb-done - Merge branch to main and cleanup worktree
# Usage: wb-done [--squash|--rebase] [--skip-merge] [--target <branch>] [--keep-remote] [--dry-run]

set -euo pipefail

SCRIPT_DIR="${0:A:h}"
source "$SCRIPT_DIR/wb-lib"

usage() {
    echo "Usage: wb-done [branch-name] [options]"
    echo ""
    echo "Merges a branch into main and cleans up the worktree."
    echo ""
    echo "Modes:"
    echo "  wb-done <branch>   Run from main worktree, specify branch to merge (recommended)"
    echo "  wb-done            Run from feature worktree, infers branch from HEAD"
    echo ""
    echo "Options:"
    echo "  --squash        Squash all commits into one before merging"
    echo "  --rebase        Rebase onto target branch before merging"
    echo "  --skip-merge    Skip merge (use when already merged via PR)"
    echo "  --target <branch>  Target branch to merge into (default: auto-detect)"
    echo "  --keep-remote   Don't delete the remote branch"
    echo "  --dry-run       Show what would be done without executing"
    echo "  --discard-changes  Discard uncommitted changes (DANGEROUS)"
    exit 1
}

# Helper: find worktree path for a branch name
find_worktree_for_branch() {
    local branch="$1"
    git worktree list --porcelain | awk -v branch="$branch" '
        /^worktree / { path = substr($0, 10) }
        /^branch refs\/heads\// {
            b = substr($0, 19)
            if (b == branch) print path
        }
    '
}

# Parse arguments
merge_strategy=""
skip_merge=false
target_branch=""
keep_remote=false
dry_run=false
discard_changes=false
source_branch=""

# Check if first argument is a branch name (not a flag)
if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
    source_branch="$1"
    shift
fi

while [[ $# -gt 0 ]]; do
    case "$1" in
        --squash)
            merge_strategy="squash"
            ;;
        --rebase)
            merge_strategy="rebase"
            ;;
        --skip-merge)
            skip_merge=true
            ;;
        --target)
            shift
            if [[ $# -eq 0 ]]; then
                echo "ERROR: --target requires a branch name | ACTION: Provide branch name after --target"
                exit 1
            fi
            target_branch="$1"
            ;;
        --keep-remote)
            keep_remote=true
            ;;
        --dry-run)
            dry_run=true
            ;;
        --discard-changes)
            discard_changes=true
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "ERROR: Unknown option: $1 | ACTION: Use -h or --help to see valid options"
            exit 1
            ;;
    esac
    shift
done

# Verify we're in a git repository
git_root=$(wb_require_git_root)

# Get main worktree (first in list)
main_worktree=$(wb_get_main_worktree)

# Determine mode based on source_branch argument
running_from_main=false
if [[ -n "$source_branch" ]]; then
    # Mode: running from main with branch argument
    current_dir=$(pwd)
    if [[ "$current_dir" != "$main_worktree" ]]; then
        echo "ERROR: When specifying a branch, must run from main worktree | ACTION: cd $main_worktree and run 'wb done $source_branch'"
        exit 1
    fi
    running_from_main=true

    # Find the worktree for this branch
    feature_worktree=$(find_worktree_for_branch "$source_branch")
    if [[ -z "$feature_worktree" ]]; then
        echo "ERROR: No worktree found for branch '$source_branch' | ACTION: Check branch name with 'wb list'"
        exit 1
    fi

    current_branch="$source_branch"
    current_worktree="$feature_worktree"
else
    # Mode: running from feature worktree (legacy)
    current_worktree=$(pwd)

    # Check if we're in the main worktree (not allowed in this mode)
    if [[ "$current_worktree" == "$main_worktree" ]]; then
        echo "ERROR: Cannot run wb-done from main worktree without branch argument | ACTION: Specify branch: 'wb done <branch-name>' or navigate to a feature worktree"
        exit 1
    fi

    # Get current branch from HEAD
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ "$current_branch" == "HEAD" ]]; then
        echo "ERROR: Detached HEAD state | ACTION: Checkout a branch first"
        exit 1
    fi
fi

# Get default branch if target not specified
if [[ -z "$target_branch" ]]; then
    target_branch=$(wb_get_default_branch)
    if [[ -z "$target_branch" ]]; then
        echo "ERROR: Cannot determine default branch | ACTION: Specify target with --target <branch>"
        exit 1
    fi
fi

# Check for uncommitted changes in the feature worktree
has_uncommitted=false
if $running_from_main; then
    # Need to check the feature worktree, not current directory
    if ! git -C "$current_worktree" diff --quiet || ! git -C "$current_worktree" diff --cached --quiet; then
        has_uncommitted=true
    fi
else
    if ! git diff --quiet || ! git diff --cached --quiet; then
        has_uncommitted=true
    fi
fi

if $has_uncommitted; then
    if $discard_changes; then
        echo "WARNING: Uncommitted changes will be discarded"
    else
        echo "ERROR: Uncommitted changes in worktree $current_worktree | ACTION: Commit or stash changes, or use --discard-changes to force"
        exit 1
    fi
fi

# Check if branch is already merged
already_merged=false
if git merge-base --is-ancestor "$current_branch" "$target_branch" 2>/dev/null; then
    already_merged=true
    if ! $skip_merge; then
        echo "WARNING: Branch '$current_branch' is already merged into '$target_branch' | ACTION: Consider using --skip-merge or removing worktree with wb rm"
        skip_merge=true
    fi
fi

# Check if remote branch exists
remote_branch_exists=false
if git ls-remote --exit-code --heads origin "$current_branch" >/dev/null 2>&1; then
    remote_branch_exists=true
fi

# Print plan
echo "=== wb-done ==="
echo ""
echo "Branch:       $current_branch"
echo "Target:       $target_branch"
echo "Worktree:     $current_worktree"
echo "Main:         $main_worktree"
echo ""

if $skip_merge; then
    echo "Merge:        SKIP (--skip-merge or already merged)"
else
    echo "Merge:        ${merge_strategy:-standard}"
fi

echo "Cleanup:      worktree + local branch"
if $remote_branch_exists; then
    if $keep_remote; then
        echo "Remote:       KEEP (--keep-remote)"
    else
        echo "Remote:       DELETE origin/$current_branch"
    fi
else
    echo "Remote:       (no remote branch)"
fi
echo ""

if $dry_run; then
    echo "DRY RUN - no changes made"
    exit 0
fi

# Phase 1: Merge (unless skipped)
if ! $skip_merge; then
    echo "=== Merging ==="

    # Fetch latest
    echo "Fetching latest from origin..."
    if ! git fetch origin "$target_branch" 2>&1; then
        echo "ERROR: Failed to fetch $target_branch | ACTION: Check network connection and remote access"
        exit 1
    fi

    # Go to main worktree to perform merge
    echo "Switching to main worktree..."
    cd "$main_worktree"

    # Ensure we're on target branch
    if ! git checkout "$target_branch" 2>&1; then
        echo "ERROR: Failed to checkout $target_branch | ACTION: Ensure branch exists and no conflicts"
        exit 1
    fi

    # Pull latest
    echo "Pulling latest $target_branch..."
    if ! git pull origin "$target_branch" 2>&1; then
        echo "ERROR: Failed to pull $target_branch | ACTION: Check for merge conflicts or network issues"
        exit 1
    fi

    # Perform merge based on strategy
    echo "Merging '$current_branch' into '$target_branch'..."

    case "$merge_strategy" in
        squash)
            if ! git merge --squash "$current_branch"; then
                echo "ERROR: Merge conflict during squash | ACTION: Resolve conflicts in $main_worktree, then run 'wb-done --skip-merge' from worktree"
                exit 1
            fi
            # Squash merge requires a commit
            git commit -m "Squash merge branch '$current_branch'"
            ;;
        rebase)
            # For rebase strategy, we rebase the feature branch first, then fast-forward merge
            cd "$current_worktree"
            if ! git rebase "$target_branch"; then
                echo "ERROR: Rebase conflict | ACTION: Resolve conflicts, run 'git rebase --continue', then run 'wb-done --skip-merge'"
                exit 1
            fi
            cd "$main_worktree"
            git merge --ff-only "$current_branch"
            ;;
        *)
            if ! git merge --no-ff "$current_branch" -m "Merge branch '$current_branch'"; then
                echo "ERROR: Merge conflict | ACTION: Resolve conflicts in $main_worktree, commit, then run 'wb-done --skip-merge' from worktree"
                exit 1
            fi
            ;;
    esac

    # Push to remote
    echo "Pushing $target_branch to origin..."
    git push origin "$target_branch"

    echo "Merge complete."
    echo ""
fi

# Phase 2: Cleanup
echo "=== Cleanup ==="

# Make sure we're in main worktree for cleanup
cd "$main_worktree"

# Remove worktree
echo "Removing worktree at $current_worktree..."
if $discard_changes; then
    if ! git worktree remove --force "$current_worktree" 2>&1; then
        echo "ERROR: Failed to remove worktree | ACTION: Check 'git worktree list' for issues"
        exit 1
    fi
else
    if ! git worktree remove "$current_worktree" 2>&1; then
        echo "ERROR: Failed to remove worktree | ACTION: Check for uncommitted changes or use --discard-changes"
        exit 1
    fi
fi
echo "Worktree removed."

# Delete local branch
echo "Deleting local branch '$current_branch'..."
if git branch -d "$current_branch" 2>&1; then
    echo "Local branch deleted."
else
    # Force delete if needed (branch was squash/rebase merged so -d might fail)
    echo "WARNING: Branch not detected as merged (possibly squash/rebase), force deleting..."
    git branch -D "$current_branch"
    echo "Local branch force deleted."
fi

# Delete remote branch
if $remote_branch_exists && ! $keep_remote; then
    echo "Deleting remote branch 'origin/$current_branch'..."
    if git push origin --delete "$current_branch" 2>&1; then
        echo "Remote branch deleted."
    else
        echo "WARNING: Could not delete remote branch (may already be deleted)"
    fi
fi

echo ""
echo "=========="
echo "SUCCESS: Branch '$current_branch' finished and cleaned up"
echo "BRANCH: $current_branch (deleted)"

if ! $running_from_main; then
    # Running from feature worktree - directory was deleted, need to navigate
    echo ""
    echo "IMPORTANT: Your current directory has been deleted."
    echo "NAVIGATE: cd $main_worktree"
    echo "EXECUTE: cd $main_worktree"
fi
